#!/usr/bin/env ruby
require 'optparse'
cmd = File.basename __FILE__

opts = {}
op = OptionParser.new {|o|
  o.banner = "Usage: #{cmd} [options and args]"
  o.separator ""
}
op.parse!

class Todo
  attr_accessor :todo_file, :done_file, :colorizer

  def initialize(opts={})
    # TODO may read from .todorc
    defaults = { 
      todo_file: 'todo.txt',
      done_file: 'done.txt'
    }
    @colorizer = 'todorb_colorizer'
    @opts = defaults.merge opts
    @todo_file = @opts[:todo_file]
    @done_file = @opts[:done_file]
  end

  def ed_command command, *input_text
    text = input_text.empty? ? nil : "\n#{input_text.join(' ')}\n."
    IO.popen("ed -s #{todo_file}", 'w') {|pipe|
      script = <<END
#{command}#{text}
wq
END
      #puts script
      pipe.puts script
      pipe.close
    }
  end

  def catn(list_file = todo_file)
    $stderr.puts
    exec <<END
cat -n #{list_file} | #{colorizer}
echo 1>&2 2>/dev/null
END
  end

  def list_done
    catn done_file
  end

  def filter context_or_project
    $stderr.puts
    exec <<END
cat -n #{todo_file} | grep '#{context_or_project.sub(/^\//,'')}\\>' | #{colorizer} #{context_or_project}
echo 1>&2 2>/dev/null
END
  end

  def mark_done range
    return unless range =~ /\S/
    exec <<END
cat #{todo_file} | sed -n '#{range}p' | 
  awk '{print d " | " $0}' "d=$(date +'%Y-%m-%d')" >> #{done_file}
echo "#{range}d\nwq\n" | ed -s #{todo_file} 
END
  end

  def report
    tag_regex = /[@\+]\S+/
    report = [:todo, :done].
      select {|a| File.exist?(send("#{a}_file"))}.
      inject({}) {|m, list|
        file = "#{list}_file"
        File.read(send(file)).scan(tag_regex).group_by {|t| t}.
          map {|k, v|
            m[k] ||= {}
            m[k][list] = (m[k][list] || 0) + v.size
          }
        m
      }
    # count priority items per tag
    File.readlines(todo_file).inject(report) {|report, line|
      line.scan(tag_regex).each {|tag|
        report[tag][:priority] ||= 0
        if line =~ /!/
          report[tag][:priority] = report[tag][:priority] + 1
        end
      }; report
    }
    longest_tag_len = report.keys.reduce(0) {|max, key| [max, key.length].max} + 3
    placeholders = "%-#{longest_tag_len}s %8s %8s %8s" 
    headers = %w(tag priority todo done)
    IO.popen(colorizer, 'w') {|pipe|
      pipe.puts(placeholders % headers)
      pipe.puts placeholders.scan(/\d+/).map {|a|'-'*(a.to_i)}.join(' ')
      report.keys.sort_by {|k| k.downcase}.each {|k|
        pipe.puts placeholders % [k, report[k][:priority], report[k][:todo], report[k][:done]]
      }
    }
  end
end


t = Todo.new
command = ARGV.shift

/^(?<context>@\S+)$/ =~ command
/^(?<project>\+\S+)$/ =~ command
/^(?<search_word>\/.+)$/ =~ command

# TODO allow filtering done by context

if context && ARGV.empty?
  t.filter context
elsif project && ARGV.empty?
  t.filter project
elsif search_word 
  t.filter search_word
elsif command == 'done' && !ARGV.empty?
  t.mark_done ARGV.join(' ')
elsif command == 'done' && ARGV.empty?
  t.list_done
elsif command == 'ls' && ARGV.empty?
  t.report
elsif command.nil?
  t.catn 
else
  t.ed_command command, *ARGV
end

