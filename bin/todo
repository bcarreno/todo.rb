#!/usr/bin/env ruby

cmd = File.basename __FILE__

class Todo
  attr_accessor :todo_file, :done_file, :colorizer

  def initialize(opts={})
    # TODO may read from .todorc
    defaults = { 
      todo_file: 'todo.txt',
      done_file: 'done.txt'
    }
    @colorizer = 'todorb_colorizer'
    @opts = defaults.merge opts
    @todo_file = @opts[:todo_file]
    @done_file = @opts[:done_file]
  end

  def ed_command command, *input_text
    text = input_text.empty? ? nil : "\n#{input_text.join(' ')}\n."
    IO.popen("ed -s #{todo_file}", 'w') {|pipe|
      script = <<END
#{command}#{text}
wq
END
      #puts script
      pipe.puts script
      pipe.close
    }
  end

  def catn(list_file = todo_file)
    $stderr.puts
    exec <<END
cat -n #{list_file} | #{colorizer}
echo 1>&2 2>/dev/null
END
  end

  def list_done
    catn done_file
  end

  def filter context_or_project
    s = context_or_project
    $stderr.puts
    # don't put /< before the grep arg
    grep_arg = s =~ /^!/ ? s : "#{s.sub(/^\//,'')}\\>"
    exec <<END
cat -n #{todo_file} | grep -i '#{grep_arg}' | #{colorizer} '#{s}'
echo 1>&2 2>/dev/null
END
  end

  def mark_done range
    return unless range =~ /\S/
    exec <<END
cat #{todo_file} | sed -n '#{range}p' | 
  awk '{print d " | " $0}' "d=$(date +'%Y-%m-%d')" >> #{done_file}
echo "#{range}d\nwq\n" | ed -s #{todo_file} 
END
  end

  TAG_REGEX = /[@\+]\S+/
   
  def report
    report_data = get_report_data 
    # count priority items per tag
    File.readlines(todo_file).inject(report_data) {|report_data, line|
      line.scan(TAG_REGEX).each {|tag|
        report_data[tag][:priority] ||= 0
        if line =~ /!/
          report_data[tag][:priority] = report_data[tag][:priority] + 1
        end
      }; report_data
    }
    longest_tag_len = report_data.keys.reduce(0) {|max, key| [max, key.length].max} + 3
    placeholders = "%-#{longest_tag_len}s %8s %8s %8s" 
    headers = %w(tag priority todo done)
    IO.popen(colorizer, 'w') {|pipe|
      pipe.puts(placeholders % headers)
      pipe.puts placeholders.scan(/\d+/).map {|a|'-'*(a.to_i)}.join(' ')
      report_data.keys.sort_by {|k| k.downcase}.each {|k|
        pipe.puts placeholders % [k, report_data[k][:priority], report_data[k][:todo], report_data[k][:done]]
      }
    }
  end

  def get_report_data 
    [:todo, :done].
      select {|a| File.exist?(send("#{a}_file"))}.
      inject({}) {|m, list|
        file = "#{list}_file"
        File.read(send(file)).scan(TAG_REGEX).group_by {|t| t}.
          map {|k, v|
            m[k] ||= {todo:0,done:0,priority:0}
            m[k][list] = (m[k][list] || 0) + v.size
          }
        m
      }
  end

  def self.expand_tag(t)
    re = /^#{Regexp.escape(t)}/
    match = new.get_report_data.keys.detect {|key| key =~ re} 
    if match && match != t
      $stderr.puts "Expanding #{t} -> #{match}"
      match
    else
      t
    end
  end
end

t = Todo.new

args = ARGV.dup

# Autoexpand any tags

args = args.map {|a| 
  if a =~ /^(@@|\+\+)/ && (expanded_tag = Todo.expand_tag(a[1..-1]))
    expanded_tag
  else
    a
  end
}


command = args.shift

/^(?<context>@\S+)$/ =~ command
/^(?<project>\+\S+)$/ =~ command
/^(?<search_word>\/.+)$/ =~ command

# TODO allow filtering done by context

if context && args.empty?
  t.filter Todo.expand_tag(context)
elsif context && !args.empty?
  t.ed_command('a', [Todo.expand_tag(context)] + args)
elsif project && args.empty?
  t.filter Todo.expand_tag(project)
elsif project && !args.empty?
  t.ed_command('a', [Todo.expand_tag(project)] + args)
elsif search_word 
  t.filter search_word
elsif command =~ /^pri/ && args.empty?
  t.filter '!'
elsif command == 'done' && !args.empty?
  t.mark_done args.join(' ')
elsif command == 'done' && args.empty?
  t.list_done
elsif command == 'ls' && args.empty?
  t.report
elsif command.nil?
  t.catn 
else
  t.ed_command command, *args
end

