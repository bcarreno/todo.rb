#!/usr/bin/env ruby
require 'optparse'
cmd = File.basename __FILE__

opts = {}
op = OptionParser.new {|o|
  o.banner = "Usage: #{cmd} [options and args]"
  o.separator ""
}
op.parse!

class Todo
  attr_accessor :todo_file, :done_file, :colorizer

  def initialize(opts={})
    # TODO may read from .todorc

    defaults = { 
      todo_file: 'todo.txt',
      done_file: 'done.txt'
    }
    @colorizer = 'todorb_colorizer'
    @opts = defaults.merge opts
    @todo_file = @opts[:todo_file]
    @done_file = @opts[:done_file]
  end

  def ed_command command, *input_text
    text = input_text.empty? ? nil : "\n#{input_text.join(' ')}\n."
    IO.popen("ed -s #{todo_file}", 'w') {|pipe|
      script = <<END
#{command}#{text}
wq
END
      #puts script
      pipe.puts script
      pipe.close
    }
  end

  def catn
    $stderr.puts
    exec <<END
cat -n #{todo_file} | #{colorizer}
echo
END
  end

  def filter context_or_project
    $stderr.puts
    exec <<END
cat -n #{todo_file} | grep '#{context_or_project}\\>' | #{colorizer} #{context_or_project}
echo
END
  end

  def done range
    puts range
    exec <<END
cat #{todo_file} | sed -n '#{range}p' | 
  awk '{print d " | " $0}' "d=$(date +'%Y-%m-%d')" >> #{done_file}
echo "#{range}d\nwq\n" | ed -s #{todo_file} 
END

  end
end


t = Todo.new
command = ARGV.shift

/^(?<context>@\S+)$/ =~ command
/^(?<project>\+\S+)$/ =~ command
/^\/(?<search_word>\S+)$/ =~ command

if context 
  t.filter context
elsif project 
  t.filter project
elsif search_word
  t.filter search_word
elsif command == 'done'
  t.done ARGV.join(' ')
elsif command.nil?
  t.catn 
else
  t.ed_command command, *ARGV
end

